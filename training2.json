[
  {
    "messages": [
      {
        "role": "user",
        "content": "generate a contract that decreases a value"
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n  #[ink::contract]\n  mod decrementer {\n  \n      #[ink(storage)]\n      pub struct Decrementer {\n          value: i32,\n      }\n  \n      impl Decrementer {\n          #[ink(constructor)]\n          pub fn new(init_value: i32) -> Self {\n              Self {\n                  value: init_value,\n              }\n          }\n  \n          #[ink(constructor)]\n          pub fn default() -> Self {\n              Self {\n                  value: Default::default(),\n              }\n          }\n  \n          #[ink(message)]\n          pub fn get(&self) -> i32 {\n              self.value\n          }\n  \n          #[ink(message)]\n          pub fn decrement(&mut self, by: i32) {\n              self.value -= by;\n          }\n      }\n  }\n  "
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "generate a contract that multiplies a value"
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod incrementer {\n\n    #[ink(event)]\n    pub struct Incremented {\n        from: Option<AccountId>,\n        value: u32,\n    }\n\n    #[ink(storage)]\n    pub struct Incrementer {\n        value: u32,\n    }\n\n    impl Incrementer {\n        #[ink(constructor)]\n        pub fn new(init_value: u32) -> Self {\n            Self { value: init_value }\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new(Default::default())\n        }\n\n        #[ink(message)]\n        pub fn get(&self) -> u32 {\n            self.value\n        }\n\n        #[ink(message)]\n        pub fn inc(&mut self, by: u32) {\n            self.value += by;\n\n            let from = self.env().caller();\n            self.env().emit_event(Incremented {\n                from: Some(from),\n                value: self.value,\n            });\n        }\n    }\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "generate a contract that holds a list of members.  Only members can add addresses to the list and members can remove themselves from the list"
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod memberlist {\n\n    use ink::prelude::vec::Vec;\n\n    #[ink(event)]\n    pub struct MemberAdded {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n    }\n\n    #[ink(event)]\n    pub struct MemberRemoved {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n    }\n\n    #[ink(storage)]\n    pub struct MemberList {\n        members: Vec<AccountId>,\n        owner: AccountId,\n    }\n\n    impl MemberList {\n        #[ink(constructor)]\n        pub fn new(init_member: AccountId) -> Self {\n            let mut members = Vec::new();\n            members.push(init_member.clone());\n\n            Self {\n                members,\n                owner: init_member,\n            }\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new(Self::env().caller())\n        }\n\n        #[ink(message)]\n        pub fn add_member(&mut self, to: AccountId) {\n            assert_eq!(\n                self.owner,\n                self.env().caller(),\n                \"Only owner can add members\"\n            );\n\n            if !self.members.contains(&to) {\n                self.members.push(to.clone());\n                self.env().emit_event(MemberAdded {\n                    from: Some(self.env().caller()),\n                    to: Some(to),\n                });\n            }\n        }\n\n        #[ink(message)]\n        pub fn remove_member(&mut self, to: AccountId) {\n            assert_eq!(\n                self.owner,\n                self.env().caller(),\n                \"Only owner can remove members\"\n            );\n\n            let index = self.members.iter().position(|&r| r == to);\n            if let Some(index) = index {\n                self.members.swap_remove(index);\n\n                self.env().emit_event(MemberRemoved {\n                    from: Some(self.env().caller()),\n                    to: Some(to),\n                });\n            }\n        }\n\n        #[ink(message)]\n        pub fn get_members(&self) -> Vec<AccountId> {\n            self.members.clone()\n        }\n    }\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "generate a contract that is a multi-sig wallet for 2 users. The users are set when it is deployed.  TZERO can be deposited into the contract.  Users can propose sending TZERO to an address but it won't be sent until 2/2 users approve the transfer."
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod multi_sig {\n    use ink::prelude::vec::Vec;\n    use ink::storage::Mapping;\n\n    #[ink(event)]\n    pub struct Approval {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    #[ink(storage)]\n    pub struct MultiSig {\n        owners: Vec<AccountId>,\n        balances: Mapping<AccountId, Balance>,\n        approvals: Mapping<(AccountId, AccountId), Balance>,\n    }\n\n    impl MultiSig {\n        #[ink(constructor)]\n        pub fn new(owners: Vec<AccountId>) -> Self {\n            Self {\n                owners,\n                balances: Default::default(),\n                approvals: Default::default(),\n            }\n        }\n\n        #[ink(constructor, payable)]\n        pub fn default() -> Self {\n            let caller = Self::env().caller();\n            let mut owners = Vec::new();\n            owners.push(caller);\n\n            Self::new(owners)\n        }\n\n        #[ink(message, payable)]\n        pub fn receive(&mut self) {\n            let value = self.env().transferred_value();\n            let caller = self.env().caller();\n\n            self.balances.insert(caller, &value);\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> bool {\n            let caller = self.env().caller();\n\n            if self.owners.contains(&caller) {\n                self.approve(caller, to, value);\n\n                return true;\n            }\n\n            false\n        }\n\n        #[ink(message)]\n        pub fn approve(&mut self, from: AccountId, to: AccountId, value: Balance) {\n            let caller = self.env().caller();\n\n            if self.owners.contains(&caller) {\n                let key = (from, to);\n                let approval = self.approvals.get(&key).unwrap_or_default();\n                self.approvals.insert(key, &(approval + value));\n\n                self.env().emit_event(Approval {\n                    from: Some(from),\n                    to: Some(to),\n                    value: value,\n                });\n            }\n        }\n\n        #[ink(message)]\n        pub fn complete(&mut self, from: AccountId, to: AccountId, value: Balance) -> bool {\n            let caller = self.env().caller();\n\n            if self.owners.contains(&caller) {\n                let key = (from, to);\n                let approval = self.approvals.take(&key).unwrap_or_default();\n                if approval >= value {\n                    let balance = self.balances.get(&from).unwrap_or_default();\n                    if balance >= value {\n                        self.balances.insert(from, &(balance - value));\n                        self.balances\n                            .insert(to, &(self.balances.get(&to).unwrap_or_default() + value));\n\n                        return true;\n                    }\n                }\n            }\n\n            false\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> Balance {\n            self.balances.get(&owner).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn owners(&self) -> Vec<AccountId> {\n            self.owners.clone()\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "generate a contract that takes stores accountIDs and an array of status messages that only the account owner can add  to.  Also add the ability to read and like status messages of other users by providing the address and index of the message.  Add a function to get the list of all messages for a user."
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod message_board {\n    use ink::prelude::string::String;\n    use ink::prelude::vec::Vec;\n    use ink::storage::Mapping;\n\n    #[ink(event)]\n    pub struct MessageAdded {\n        from: Option<AccountId>,\n        message: String,\n    }\n\n    #[ink(storage)]\n    pub struct MessageBoard {\n        messages: Vec<String>,\n        message_owners: Mapping<AccountId, u32>,\n    }\n\n    impl MessageBoard {\n        #[ink(constructor)]\n        pub fn new(init_message: String) -> Self {\n            let mut messages = Vec::new();\n            messages.push(init_message.clone());\n\n            let mut message_owners = Mapping::default();\n            let message_owner = Self::env().caller();\n            message_owners.insert(&message_owner, &0);\n\n            Self {\n                messages,\n                message_owners,\n            }\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            let default_message = String::from(\"Hello ink!\");\n            Self::new(default_message)\n        }\n\n        #[ink(message)]\n        pub fn get_message(&self, index: u32) -> Option<(AccountId, String)> {\n            let owner = self.env().caller();\n            let message = self.messages.get(index as usize).cloned();\n            match message {\n                Some(msg) => Some((owner, msg)),\n                None => None,\n            }\n        }\n\n        #[ink(message)]\n        pub fn like_message(&mut self, index: u32) {\n            let owner = self.env().caller();\n            let message = self.messages.get_mut(index as usize);\n            match message {\n                Some(msg) => {\n                    assert!(self.message_owners.get(&owner) != Some(index));\n                    *msg += \"❤️\";\n                }\n                None => {}\n            }\n        }\n\n        #[ink(message)]\n        pub fn add_message(&mut self, new_message: String) {\n            let owner = self.env().caller();\n            let message_count = self.messages.len() as u32;\n            self.messages.push(new_message.clone());\n            self.message_owners.insert(owner, &message_count);\n            self.env().emit_event(MessageAdded {\n                from: Some(owner),\n                message: new_message,\n            });\n        }\n\n        #[ink(message)]\n        pub fn message_count(&self) -> u32 {\n            self.messages.len() as u32\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "write a contract that acts like a credit card.  The user can deposit and withdrawal from their own accounts and they can also give an allowance to other addresses, allowing the other addresses to withdrawal up to the allowance.  Add a credit score which increases based on the time the user has a balance and the amount of that balance.  (make sure to track timestamp on deposit + withdrawals and have a weight system for larger vs smaller deposit / withdrawals also include withdrawals from other parties)."
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod credit_card {\n\n    #[ink(event)]\n    pub struct Deposit {\n        from: Option<AccountId>,\n        value: Balance,\n        timestamp: u64,\n        score: u128,\n    }\n\n    #[ink(event)]\n    pub struct Withdraw {\n        from: Option<AccountId>,\n        value: Balance,\n        timestamp: u64,\n        score: u128,\n    }\n\n    #[ink(event)]\n    pub struct Allowance {\n        to: Option<AccountId>,\n        value: Balance,\n        timestamp: u64,\n        score: u128,\n    }\n\n    #[ink(storage)]\n    pub struct CreditCard {\n        balance: Balance,\n        allowance: Balance,\n        last_activity: u64,\n        score: u128,\n    }\n\n    impl CreditCard {\n        #[ink(constructor, payable)]\n        pub fn new(init_value: Balance) -> Self {\n            let transferred_value = Self::env().transferred_value();\n            assert!(\n                transferred_value == init_value,\n                \"Transferred value doesn't match the required initial value\"\n            );\n            let timestamp = Self::env().block_timestamp();\n            CreditCard {\n                balance: init_value,\n                allowance: 0,\n                last_activity: timestamp,\n                score: 0,\n            }\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new(Default::default())\n        }\n\n        #[ink(message)]\n        pub fn deposit(&mut self) {\n            let value = self.env().transferred_value();\n\n            let timestamp = self.env().block_timestamp();\n            let last_activity = self.last_activity;\n            let mut score: u128 = 0;\n            if value > 100_000 {\n                score = 1;\n            } else if last_activity != 0 && value % 10_000 == 0 {\n                let time_passed = timestamp - last_activity;\n                let time_score = u128::from(time_passed) / 60;\n                score += time_score * value / 10_000;\n            }\n\n            self.score += score;\n            self.balance += value;\n            self.last_activity = timestamp;\n\n            self.env().emit_event(Deposit {\n                from: Some(self.env().caller()),\n                value,\n                timestamp,\n                score,\n            });\n        }\n\n        #[ink(message)]\n        pub fn withdraw(&mut self, value: Balance) -> Result<(), Error> {\n            let caller = self.env().caller();\n            if self.balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n\n            let timestamp = self.env().block_timestamp();\n            let last_activity = self.last_activity;\n            let mut score: u128 = 0;\n            if value > 100_000 {\n                score = 1;\n            } else if last_activity != 0 && value % 10_000 == 0 {\n                let time_passed = timestamp - last_activity;\n                let time_score = u128::from(time_passed) / 60;\n                score += time_score * value / 10_000;\n            }\n\n            self.score += score;\n            self.balance -= value;\n            self.last_activity = timestamp;\n\n            self.env().emit_event(Withdraw {\n                from: Some(caller),\n                value,\n                timestamp,\n                score,\n            });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn get_balance(&self) -> Balance {\n            self.balance\n        }\n\n        #[ink(message)]\n        pub fn allowance(&self) -> Balance {\n            self.allowance\n        }\n\n        #[ink(message)]\n        pub fn set_allowance(&mut self, value: Balance) {\n            let timestamp = self.env().block_timestamp();\n            let last_activity = self.last_activity;\n            let mut score: u128 = 0;\n            if value > 100_000 {\n                score = 1;\n            } else if last_activity != 0 && value % 10_000 == 0 {\n                let time_passed = timestamp - last_activity;\n                let time_score = u128::from(time_passed) / 60;\n                score += time_score * value / 10_000;\n            }\n\n            self.score += score;\n            self.allowance = value;\n\n            self.env().emit_event(Allowance {\n                to: Some(self.env().caller()),\n                value,\n                timestamp,\n                score,\n            });\n        }\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(\n        feature = \"std\",\n        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)\n    )]\n    pub enum Error {\n        InsufficientBalance,\n    }\n}\n"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are an AI assistant that generates Ink smart contracts which are written in Rust for the Aleph Zero blockchain.  Make sure to start each contract with this exact string `\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n`\nto avoid using the standard library for Rust."
      },
      {
        "role": "user",
        "content": "write a contract that acts like a credit card.  The user can deposit and withdrawal from their own accounts and they can also give an allowance to other addresses, allowing the other addresses to withdrawal up to the allowance.  Add a credit score which increases based on the time the user has a balance and the amount of that balance.  (make sure to track timestamp on deposit + withdrawals and have a weight system for larger vs smaller deposit / withdrawals also include withdrawals from other parties)."
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod credit_card {\n\n    use ink::storage::Mapping;\n\n    #[ink(event)]\n    pub struct Deposit {\n        from: Option<AccountId>,\n        value: Balance,\n        timestamp: u64,\n        score: u128,\n    }\n\n    #[ink(event)]\n    pub struct Withdraw {\n        from: Option<AccountId>,\n        value: Balance,\n        timestamp: u64,\n        score: u128,\n    }\n\n    #[ink(event)]\n    pub struct Allowance {\n        to: Option<AccountId>,\n        value: Balance,\n        timestamp: u64,\n        score: u128,\n    }\n\n    #[ink(storage)]\n    pub struct CreditCard {\n        balance: Balance,\n        allowances: Mapping<AccountId, Balance>,\n        last_activity: u64,\n        score: u128,\n    }\n\n    impl CreditCard {\n        #[ink(constructor, payable)]\n        pub fn new(init_value: Balance) -> Self {\n            let transferred_value = Self::env().transferred_value();\n            assert!(\n                transferred_value == init_value,\n                \"Transferred value doesn't match the required initial value\"\n            );\n            let timestamp = Self::env().block_timestamp();\n            CreditCard {\n                balance: init_value,\n                allowances: Mapping::default(),\n                last_activity: timestamp,\n                score: 0,\n            }\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new(Default::default())\n        }\n\n        #[ink(message)]\n        pub fn deposit(&mut self) {\n            let value = self.env().transferred_value();\n\n            let timestamp = self.env().block_timestamp();\n            let last_activity = self.last_activity;\n            let mut score: u128 = 0;\n            if value > 100_000 {\n                score = 1;\n            } else if last_activity != 0 && value % 10_000 == 0 {\n                let time_passed = timestamp - last_activity;\n                let time_score = u128::from(time_passed) / 60;\n                score += time_score * value / 10_000;\n            }\n\n            self.score += score;\n            self.balance += value;\n            self.last_activity = timestamp;\n\n            self.env().emit_event(Deposit {\n                from: Some(self.env().caller()),\n                value,\n                timestamp,\n                score,\n            });\n        }\n\n        #[ink(message)]\n        pub fn get_balance(&self) -> Balance {\n            self.balance\n        }\n\n        #[ink(message)]\n        pub fn set_allowance(&mut self, to: AccountId, value: Balance) {\n            let timestamp = self.env().block_timestamp();\n            let last_activity = self.last_activity;\n            let mut score: u128 = 0;\n            if value > 100_000 {\n                score = 1;\n            } else if last_activity != 0 && value % 10_000 == 0 {\n                let time_passed = timestamp - last_activity;\n                let time_score = u128::from(time_passed) / 60;\n                score += time_score * value / 10_000;\n            }\n\n            self.score += score;\n            self.allowances.insert(to, &value);\n\n            self.env().emit_event(Allowance {\n                to: Some(self.env().caller()),\n                value,\n                timestamp,\n                score,\n            });\n        }\n\n        #[ink(message)]\n        pub fn allowance(&self, account: AccountId) -> Balance {\n            return self.allowances.get(account).unwrap_or(0);\n        }\n\n        #[ink(message)]\n        pub fn withdraw(&mut self, value: Balance) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let caller_allowance = self.allowances.get(caller).unwrap_or(0);\n\n            if self.balance < value || caller_allowance < value {\n                return Err(Error::InsufficientBalance);\n            }\n\n            let timestamp = self.env().block_timestamp();\n            let last_activity = self.last_activity;\n            let mut score: u128 = 0;\n            if value > 100_000 {\n                score = 1;\n            } else if last_activity != 0 && value % 10_000 == 0 {\n                let time_passed = timestamp - last_activity;\n                let time_score = u128::from(time_passed) / 60;\n                score += time_score * value / 10_000;\n            }\n\n            self.score += score;\n            self.balance -= value;\n            self.allowances.insert(caller, &(caller_allowance - value));\n            self.last_activity = timestamp;\n\n            self.env().emit_event(Withdraw {\n                from: Some(caller),\n                value,\n                timestamp,\n                score,\n            });\n\n            Ok(())\n        }\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(\n        feature = \"std\",\n        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)\n    )]\n    pub enum Error {\n        InsufficientBalance,\n    }\n}\n"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "write a contract that is a membership.  Pay 10 TZERO to join and only members in the club can manage the funds."
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod membership {\n    use ink::prelude::vec::Vec;\n    use ink::storage::Mapping;\n\n    #[ink(event)]\n    pub struct Transfer {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    #[ink(event)]\n    pub struct MembershipGranted {\n        account_id: AccountId,\n    }\n\n    #[ink(event)]\n    pub struct MembershipRevoked {\n        account_id: AccountId,\n    }\n\n    #[ink(storage)]\n    pub struct Membership {\n        members: Vec<AccountId>,\n        balances: Mapping<AccountId, Balance>,\n    }\n\n    impl Membership {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let mut instance = Self {\n                members: Vec::new(),\n                balances: Mapping::default(),\n            };\n\n            let caller = Self::env().caller();\n            let value: Balance = Default::default();\n            instance.balances.insert(caller, &value);\n\n            instance\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new()\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<(), bool> {\n            self.ensure_member()?;\n            let from = self.env().caller();\n            self.transfer_from_to(from, to, value)\n        }\n\n        #[ink(message)]\n        pub fn grant_membership(&mut self, to: AccountId) -> Result<(), bool> {\n            self.ensure_member()?;\n\n            if self.members.contains(&to) {\n                return Err(false);\n            }\n\n            self.members.push(to.clone());\n            self.env().emit_event(MembershipGranted { account_id: to });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn revoke_membership(&mut self, to: AccountId) -> Result<(), bool> {\n            self.ensure_member()?;\n\n            let index = match self.members.iter().position(|&r| r == to) {\n                Some(index) => index,\n                None => return Err(false),\n            };\n\n            self.members.swap_remove(index);\n\n            self.env().emit_event(MembershipRevoked { account_id: to });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn members(&self) -> Vec<AccountId> {\n            self.members.clone()\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, of: AccountId) -> Balance {\n            self.balances.get(&of).unwrap_or(0)\n        }\n\n        fn ensure_member(&self) -> Result<(), bool> {\n            let caller = self.env().caller();\n            if !self.members.contains(&caller) {\n                return Err(false);\n            }\n            Ok(())\n        }\n\n        fn transfer_from_to(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<(), bool> {\n            let from_balance = self.balance_of(from);\n            if from_balance < value {\n                return Err(false);\n            }\n\n            self.balances.insert(from, &(from_balance - value));\n\n            let to_balance = self.balance_of(to);\n            self.balances.insert(to, &(to_balance + value));\n\n            self.env().emit_event(Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n\n            Ok(())\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "write a contract that is a membership DAO.  Pay to join and the users can transfer value."
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod membership {\n    use ink::prelude::vec::Vec;\n    use ink::storage::Mapping;\n\n    #[ink(event)]\n    pub struct Transfer {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    #[ink(event)]\n    pub struct MembershipGranted {\n        account_id: AccountId,\n    }\n\n    #[ink(event)]\n    pub struct MembershipRevoked {\n        account_id: AccountId,\n    }\n\n    #[ink(storage)]\n    pub struct Membership {\n        members: Vec<AccountId>,\n        balances: Mapping<AccountId, Balance>,\n    }\n\n    impl Membership {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let mut instance = Self {\n                members: Vec::new(),\n                balances: Mapping::default(),\n            };\n\n            let caller = Self::env().caller();\n            let value: Balance = Default::default();\n            instance.balances.insert(caller, &value);\n\n            instance\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new()\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<(), bool> {\n            self.ensure_member()?;\n            let from = self.env().caller();\n            self.transfer_from_to(from, to, value)\n        }\n\n        #[ink(message)]\n        pub fn grant_membership(&mut self, to: AccountId) -> Result<(), bool> {\n            self.ensure_member()?;\n\n            if self.members.contains(&to) {\n                return Err(false);\n            }\n\n            self.members.push(to.clone());\n            self.env().emit_event(MembershipGranted { account_id: to });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn revoke_membership(&mut self, to: AccountId) -> Result<(), bool> {\n            self.ensure_member()?;\n\n            let index = match self.members.iter().position(|&r| r == to) {\n                Some(index) => index,\n                None => return Err(false),\n            };\n\n            self.members.swap_remove(index);\n\n            self.env().emit_event(MembershipRevoked { account_id: to });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn members(&self) -> Vec<AccountId> {\n            self.members.clone()\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, of: AccountId) -> Balance {\n            self.balances.get(&of).unwrap_or(0)\n        }\n\n        fn ensure_member(&self) -> Result<(), bool> {\n            let caller = self.env().caller();\n            if !self.members.contains(&caller) {\n                return Err(false);\n            }\n            Ok(())\n        }\n\n        fn transfer_from_to(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<(), bool> {\n            let from_balance = self.balance_of(from);\n            if from_balance < value {\n                return Err(false);\n            }\n\n            self.balances.insert(from, &(from_balance - value));\n\n            let to_balance = self.balance_of(to);\n            self.balances.insert(to, &(to_balance + value));\n\n            self.env().emit_event(Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n\n            Ok(())\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "write a simple DAO contract"
      },
      {
        "role": "assistant",
        "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod membership {\n    use ink::prelude::vec::Vec;\n    use ink::storage::Mapping;\n\n    #[ink(event)]\n    pub struct Transfer {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    #[ink(event)]\n    pub struct MembershipGranted {\n        account_id: AccountId,\n    }\n\n    #[ink(event)]\n    pub struct MembershipRevoked {\n        account_id: AccountId,\n    }\n\n    #[ink(storage)]\n    pub struct Membership {\n        members: Vec<AccountId>,\n        balances: Mapping<AccountId, Balance>,\n    }\n\n    impl Membership {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let mut instance = Self {\n                members: Vec::new(),\n                balances: Mapping::default(),\n            };\n\n            let caller = Self::env().caller();\n            let value: Balance = Default::default();\n            instance.balances.insert(caller, &value);\n\n            instance\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self::new()\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<(), bool> {\n            self.ensure_member()?;\n            let from = self.env().caller();\n            self.transfer_from_to(from, to, value)\n        }\n\n        #[ink(message)]\n        pub fn grant_membership(&mut self, to: AccountId) -> Result<(), bool> {\n            self.ensure_member()?;\n\n            if self.members.contains(&to) {\n                return Err(false);\n            }\n\n            self.members.push(to.clone());\n            self.env().emit_event(MembershipGranted { account_id: to });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn revoke_membership(&mut self, to: AccountId) -> Result<(), bool> {\n            self.ensure_member()?;\n\n            let index = match self.members.iter().position(|&r| r == to) {\n                Some(index) => index,\n                None => return Err(false),\n            };\n\n            self.members.swap_remove(index);\n\n            self.env().emit_event(MembershipRevoked { account_id: to });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn members(&self) -> Vec<AccountId> {\n            self.members.clone()\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, of: AccountId) -> Balance {\n            self.balances.get(&of).unwrap_or(0)\n        }\n\n        fn ensure_member(&self) -> Result<(), bool> {\n            let caller = self.env().caller();\n            if !self.members.contains(&caller) {\n                return Err(false);\n            }\n            Ok(())\n        }\n\n        fn transfer_from_to(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<(), bool> {\n            let from_balance = self.balance_of(from);\n            if from_balance < value {\n                return Err(false);\n            }\n\n            self.balances.insert(from, &(from_balance - value));\n\n            let to_balance = self.balance_of(to);\n            self.balances.insert(to, &(to_balance + value));\n\n            self.env().emit_event(Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n\n            Ok(())\n        }\n    }\n}\n"
      }
    ]
  }
]
